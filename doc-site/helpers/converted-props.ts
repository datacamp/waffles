/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

type PropMetadata = {
  name: string;
  type: string;
  isOptional: boolean;
  description?: string;
};

type PropRawMetadata = {
  kind: string;
  optional: boolean;
  key: {
    kind: string;
    name: string;
  };
  value: {
    kind: string;
    name?: string;
    value?: { kind: string; name: string };
    types?: Array<{ kind: string; value: string }>;
  };
  leadingComments?: Array<{
    type: string;
    value: string;
  }>;
};

type AutoGeneratedMetadata = Record<string, any>;

type ProperPropsMetadata = Array<{ kind: string; members: PropRawMetadata[] }>;

// Find and extract proper props definitons from auto generated strucure
// Only objects with 'kind' defined as 'object' contain relevant information
// Traverse whole initial structure to find such objects and put them in flat array
function extractedProperProps(
  generatedMetadata: AutoGeneratedMetadata,
): ProperPropsMetadata {
  return Object.values(generatedMetadata).reduce((rawProps, node) => {
    // Check if node exists and is object
    if (typeof node === 'object' && node) {
      // Check whether key 'kind' has value 'object'
      if (Object.keys(node).includes('kind') && node.kind === 'object') {
        return rawProps.concat(node);
      }
      return rawProps.concat(extractedProperProps(node));
    }
    return rawProps;
  }, []);
}

// Flatten whole structure and omit props of type 'never'
function filteredRawProps(
  propsMetadata: ProperPropsMetadata,
): PropRawMetadata[] {
  return propsMetadata.reduce((rawProps, metadata) => {
    const { members } = metadata;
    const filteredMembers = members.filter((memeber) => {
      return memeber.value?.name !== 'never';
    });

    return rawProps.concat(filteredMembers);
  }, [] as PropRawMetadata[]);
}

// Remove duplicates and adjust optional flag accordingly
function noDuplicateRawProps(
  propsMetadata: PropRawMetadata[],
): PropRawMetadata[] {
  return propsMetadata.reduce((props, metadata) => {
    const indexOfDuplicatedProp = props.findIndex((prop) => {
      return prop.key.name === metadata.key.name;
    });

    // If it was duplicate, it means in general it should be optional
    // Was required only under certain conditions
    if (indexOfDuplicatedProp >= 0) {
      return [
        ...props.slice(0, indexOfDuplicatedProp),
        {
          ...props[indexOfDuplicatedProp],
          optional: true,
        },
        ...props.slice(indexOfDuplicatedProp + 1),
      ];
    }

    return props.concat(metadata);
  }, [] as PropRawMetadata[]);
}

function formattedType(metadata: PropRawMetadata): string {
  const { value } = metadata;

  // Nicely format ReactNode type
  if (value.value) {
    const { name } = value.value;
    return name.includes('ReactNode') ? 'React.ReactNode' : name;
  }

  // If it is union list all types, otherwise it's primitive type
  return value.kind === 'union'
    ? value.types!.map((type) => type.value).join(' | ')
    : value.kind;
}

function formattedDescription(
  comments: NonNullable<PropRawMetadata['leadingComments']>,
) {
  return comments[0].value.replace(/\n/g, ' ').trim();
}

// Simplify props structure
function transformedRawProps(propsMetadata: PropRawMetadata[]): PropMetadata[] {
  return propsMetadata.reduce((props, metadata) => {
    // Omit props such as aria-label
    if (metadata.key.name.includes('-')) {
      return props;
    }

    return props.concat({
      name: metadata.key.name,
      ...(metadata.leadingComments && {
        description: formattedDescription(metadata.leadingComments),
      }),
      type: formattedType(metadata),
      isOptional: metadata.optional,
    });
  }, [] as PropMetadata[]);
}

// Convert auto generated props to the format digestable by final component
function convertedProps(propsMetadata: ProperPropsMetadata): PropMetadata[] {
  const extractedProps = extractedProperProps(propsMetadata);
  const filteredProps = filteredRawProps(extractedProps);
  const noDuplicates = noDuplicateRawProps(filteredProps);

  return transformedRawProps(noDuplicates);
}

export default convertedProps;
