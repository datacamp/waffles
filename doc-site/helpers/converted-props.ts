/* eslint-disable @typescript-eslint/no-non-null-assertion */

type PropMetadata = {
  name: string;
  type: string;
  isOptional: boolean;
  description?: string;
};

type PropRawMetadata = {
  kind: string;
  optional: boolean;
  key: {
    kind: string;
    name: string;
  };
  value: {
    kind: string;
    name?: string;
    value?: { kind: string; name: string };
    types?: Array<{ kind: string; value: string }>;
  };
  leadingComments?: Array<{
    type: string;
    value: string;
  }>;
};

type AutoGeneratedMetadata = Record<string, unknown>;

type ProperPropMetadata = { kind: string; members: PropRawMetadata[] };

// Find and extract proper props definitons from auto generated strucure
// Only objects with 'kind' defined as 'object' contain relevant information
// Traverse whole initial structure to find such objects and put them in flat array
function extractedProperProps(
  generatedMetadata: AutoGeneratedMetadata,
): ProperPropMetadata[] {
  return Object.values(generatedMetadata).reduce<ProperPropMetadata[]>(
    (rawProps, node) => {
      // Check if node exists and is object
      if (typeof node === 'object' && node) {
        // Check whether key 'kind' has value 'object'
        if (
          Object.keys(node).includes('kind') &&
          (node as ProperPropMetadata).kind === 'object'
        ) {
          return rawProps.concat(node as ProperPropMetadata);
        }
        return rawProps.concat(
          extractedProperProps(node as AutoGeneratedMetadata),
        );
      }
      return rawProps;
    },
    [],
  );
}

// Flatten whole structure and omit props of type 'never'
function filteredRawProps(
  propsMetadata: ProperPropMetadata[],
): PropRawMetadata[] {
  // Extract names of all props with name 'never' from the whole collection
  const neverPropNames = propsMetadata.reduce<string[]>((names, metadata) => {
    const { members } = metadata;

    const neverNames = members.reduce<string[]>((names, val) => {
      if (val.value?.name === 'never') {
        return names.concat(val.key.name);
      }
      return names;
    }, []);

    return names.concat(neverNames);
  }, []);

  const noDuplicatedNames = [...new Set(neverPropNames)];

  return propsMetadata.reduce<PropRawMetadata[]>((rawProps, metadata) => {
    const { members } = metadata;

    // Since 'never' props are part of complex disciriminating unions, they are required only in some cases
    const adjustedMembers = members.map((member) => {
      if (noDuplicatedNames.includes(member.key.name)) {
        return {
          ...member,
          optional: true,
        };
      }
      return member;
    });

    // At the end remove props with name 'never'
    const filteredMembers = adjustedMembers.filter((memeber) => {
      return memeber.value?.name !== 'never';
    });

    return rawProps.concat(filteredMembers);
  }, []);
}

// Remove duplicates and adjust optional flag accordingly
function noDuplicateRawProps(
  propsMetadata: PropRawMetadata[],
): PropRawMetadata[] {
  return propsMetadata.reduce<PropRawMetadata[]>((props, metadata) => {
    const isDuplicate = !!props.find((prop) => {
      return prop.key.name === metadata.key.name;
    });

    if (isDuplicate) {
      return props;
    }

    return props.concat(metadata);
  }, []);
}

function formattedType(metadata: PropRawMetadata): string {
  const { value } = metadata;

  // Nicely format ReactNode type
  if (value.value) {
    const { name } = value.value;
    return name.includes('ReactNode') ? 'React.ReactNode' : name;
  }

  // If it is union list all types, otherwise it's primitive type
  return value.kind === 'union'
    ? value.types!.map((type) => type.value).join(' | ')
    : value.kind;
}

function formattedDescription(
  comments: NonNullable<PropRawMetadata['leadingComments']>,
) {
  return comments[0].value.replace(/\n/g, ' ').trim();
}

// Simplify props structure
function transformedRawProps(propsMetadata: PropRawMetadata[]): PropMetadata[] {
  return propsMetadata.reduce<PropMetadata[]>((props, metadata) => {
    // Omit props such as aria-label
    if (metadata.key.name.includes('-')) {
      return props;
    }

    return props.concat({
      name: metadata.key.name,
      ...(metadata.leadingComments && {
        description: formattedDescription(metadata.leadingComments),
      }),
      type: formattedType(metadata),
      isOptional: metadata.optional,
    });
  }, []);
}

// List required props first, sort all props by name
function sortByPropName(propsMetadata: PropMetadata[]): PropMetadata[] {
  return propsMetadata.sort((prop1, prop2) => {
    return prop1.name > prop2.name ? 1 : prop1.name > prop2.name ? -1 : 0;
  });
}

function sortTransformedProps(propsMetadata: PropMetadata[]): PropMetadata[] {
  const requiredProps: PropMetadata[] = [];
  const optionalProps: PropMetadata[] = [];

  propsMetadata.forEach((prop) => {
    if (prop.isOptional) {
      optionalProps.push(prop);
    } else {
      requiredProps.push(prop);
    }
  });

  return sortByPropName(requiredProps).concat(sortByPropName(optionalProps));
}

// Convert auto generated props to the format digestable by final component
function convertedProps(propsMetadata: AutoGeneratedMetadata): PropMetadata[] {
  const extractedProps = extractedProperProps(propsMetadata);
  const filteredProps = filteredRawProps(extractedProps);
  const noDuplicates = noDuplicateRawProps(filteredProps);
  const transformedProps = transformedRawProps(noDuplicates);

  return sortTransformedProps(transformedProps);
}

export default convertedProps;
